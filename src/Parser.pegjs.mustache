{{> initializer.pegjs}}

// Document Structure
{{> document.pegjs}}
{{> section.pegjs}}
{{> transition.pegjs}}

// Body Element
BodyElementExceptBlockQuote = BulletList / DefinitionList / Comment / Paragraph

BodyElement =
  BlankLines?
  element:(BodyElementExceptBlockQuote / BlockQuote) {
    return element;
  }

// Bullet List
BulletList =
  BlankLines?
  &(SameIndent BulletListItemMarker NormalizedToWhitespace)
  &{
    bulletMarkerStack.push(currentBulletMarker);
    currentBulletMarker = null;
    return true;
  }
  head:BulletListItem
  tail:(BlankLines? BulletListItem)* {
    currentBulletMarker = bulletMarkerStack.pop();
    var children = [head].concat(tail.map(function (t) { return t[1]; }));
    return new Elements.BulletList({ children: children });
  }

BulletListItemMarker = c:('*' / '+' / '-' / '•' / '‣' / '⁃') { return c; }

BulletListItem =
  SameIndent
  marker:BulletListItemMarker
  &{
    if (_.isNull(currentBulletMarker)) {
      currentBulletMarker = marker;
      return true;
    }
    return marker === currentBulletMarker;
  }
  body:(EmptyBulletListItemBody / BulletListItemBody) {
    return new Elements.ListItem({ children: body })
  }

EmptyBulletListItemBody = Whitespace* Endline { return []; }
BulletListItemBody = (BulletListIndent body:BodyElement* Dedent) { return body; }

BulletListIndent =
  i:Whitespace+ {
    var nextIndentSize = currentIndentSize + ParserUtil.calcIndentSize(i) + 1;
    indentIgnoreLine = location().start.line;
    indentSizeStack.push(currentIndentSize);
    currentIndentSize = nextIndentSize;
  }

// Definition List
DefinitionList =
  BlankLines?
  head:DefinitionListItem
  tail:(BlankLines? DefinitionListItem)*
  &(BlankLines) {
    var children = [head].concat(tail.map(function (t) { return t[1]; }));
    return new Elements.DefinitionList({ children: children });
  }

DefinitionListItem =
  SameIndent term:DefinitionTerm Whitespace* (':' Whitespace* DefinitionClassifier Whitespace*)* Newline
  Indent
  body:BodyElement+
  Dedent {
    return new Elements.DefinitionListItem({
      term: term,
      definition: new Elements.Definition({ children: body }),
    });
  }

DefinitionTerm =
  term:(!Endline .)+ {
    var text = term.map(function (t) { return t[1]; }).join('');
    return new Elements.Term({children: [new Text({ text: text })]});
  }

DefinitionClassifier =
  term:Nonspacechar+ {
    return term.map(function (t) { return t[1]; }).join('');
  }

// BlockQuote
BlockQuote = NestedBlockQuote / SimpleBlockQuote

BlockQuoteBody =
  head:BodyElementExceptBlockQuote
  tail:(!Attribution BodyElement)* {
    return [head].concat(_.map(tail, function (v) { return v[1]; }));
  }

Attribution =
  BlankLines
  SameIndent ('---' / '--' / '\u2014') Whitespace* &(!Endline .)
  AttributionIndent
  &{ indentIgnoreLine = location().start.line; return true; }
  body:Paragraph
  Dedent {
    return new Elements.Attribution({ children: body.children });
  }

AttributionIndent =
  &(
    RawLine // skip first line
    &{ attributesIndentList = []; return true; }
    (
      i:Whitespace+
      !Endline
      RawLine
      &{
        var size = ParserUtil.calcIndentSize(i);
        if (size < currentIndentSize) { return false; }
        attributesIndentList.push(size);
        return true;
      }
    )*
    &{
      if (_.uniq(attributesIndentList).length > 1) {
        return false;
      }
      nextIndentSize = 10000;
      if (attributesIndentList.length != 0) {
        nextIndentSize = attributesIndentList[0];
      }
      indentSizeStack.push(currentIndentSize);
      currentIndentSize = nextIndentSize;
      return true;
    }
  )

NestedBlockQuote =
  BlankLines?
  BlockQuoteIndent
  nested:BlockQuoteBody
  attribution:Attribution?
  &{ prevIndentSize = currentIndentSize; return true; }
  Dedent
  &(
    BlankLines
    i:Whitespace*
    &{ return ParserUtil.calcIndentSize(i) < prevIndentSize; }
  )
  outer:BlockQuote {
    var children = [
      new Elements.BlockQuote({ children: nested, attribution: attribution }),
    ].concat(outer.children.toArray());
    return new Elements.BlockQuote({ children: children });
  }

SimpleBlockQuote =
  BlankLines?
  BlockQuoteIndent
  children:BlockQuoteBody
  attribution:Attribution?
  Dedent {
    return new Elements.BlockQuote({ children: children, attribution: attribution });
  }

BlockQuoteIndent =
  &(i:Whitespace+
    &{
      var indentSize = ParserUtil.calcIndentSize(i);
      if (indentSize <= currentIndentSize) { return false; }
      indentSizeStack.push(currentIndentSize);
      currentIndentSize = indentSize;
      return true;
    })

// Comment
// TODO(seikichi): implmenent non empty comment
Comment =
  SameIndent '..' Whitespace* Endline { return new Elements.Comment({ }); }

InlineMarkupPreceding = c:. &{ return ParserUtil.isInlineMarkupPrefix(c); } { return c; }

// Utility for Paragraph
InlineMarkupStartString = '**' / '*' / '``' / '`' / '|' / '_`'
InlineMarkupBeggining =
  (p:InlineMarkupPreceding
   s:InlineMarkupStartString
   !Endline !Whitespace f:.
   &{ return !(p === '*' && s === '*') && !ParserUtil.isMatchPunctuations(p, f); }) /
  InlineMarkupPreceding (FootnoteReference /
                         CitationReference /
                         AnonymousSimpleHyperlinkReference /
                         NamedSimpleHyperlinkReference)

MarkupFollowedText =
  text:(!Endline !InlineMarkupBeggining .)* last:InlineMarkupPreceding {
    return new Text({ text: _.map(text, function (v) { return v[2]; }).join('') + last });
  }

NewlineFollowedText =
  text:(!Endline !InlineMarkupBeggining .)* last:Newline {
    return new Text({ text: _.map(text, function (v) { return v[2]; }).join('') + last });
  }

EofFollowedText =
  text:(!Endline !InlineMarkupBeggining .)+ Eof {
    return new Text({ text: _.map(text, function (v) { return v[2]; }).join('')  });
  }

// Paragraph
Paragraph =
  body:(!BlankLines
        SameIndent
        (ParagraphBlockStartWithInlineMarkup /
         ParagraphBlockStartWithText /
         ParagraphBlockWithoutInlineMarkup))+
  &(BlankLines / EndIndent) {
    var children =_.flatten(_.map(body, function (v) { return v[2]; }));
    return new Elements.Paragraph({ children: children });
  }

ParagraphBlockStartWithInlineMarkup =
  !Whitespace
  first:InlineMarkup
  middle:(MarkupFollowedText InlineMarkup)*
  last:(Eof / EofFollowedText / NewlineFollowedText) {
    var ret = [first].concat(_.flatten(middle));
    if (!_.isNull(last)) { ret = ret.concat(last); }
    return ret;
  }

ParagraphBlockStartWithText =
  !Whitespace
  middle:(MarkupFollowedText InlineMarkup)+
  last:(Eof / EofFollowedText / NewlineFollowedText) {
    var ret = _.flatten(middle);
    if (!_.isNull(last)) { ret = ret.concat(last); }
    return ret;
  }

ParagraphBlockWithoutInlineMarkup =
  !Whitespace
  text:(EofFollowedText / NewlineFollowedText) {
    return [text];
  }

InlineMarkupFollowing =
  Endline / c:. &{ return ParserUtil.isInlineMarkupSuffix(c); }

InlineMarkup =
  StrongEmphasis /
  Emphasis /
  InlineLiteral /
  InlineInternalTarget /
  HyperlinkReference /
  InterpretedText /
  SubstitutionReference /
  FootnoteReference /
  CitationReference

MarkupEndString =
  &{ return markupEndString.length == 1 } s:(.) &{ return s === markupEndString; } /
  &{ return markupEndString.length == 2 } s:(..) &{ return s.join('') === markupEndString; } /
  &{ return markupEndString.length == 3 } s:(...) &{ return s.join('') === markupEndString; }

MarkupTextWithIndent =
  indent:SameIndent
  text:(!Newline !(!NormalizedToWhitespace !'\\' . MarkupEndString InlineMarkupFollowing) .)+
  last:Newline? {
    var textStr = _.map(text, function (v) { return v[2]; }).join('');
    if (!_.isNull(last)) { textStr += last; }
    return new Text({ text: textStr, indent: indent });
  }

MarkupTextWithoutIndent =
  text:(!Newline !(!NormalizedToWhitespace !'\\' . MarkupEndString InlineMarkupFollowing) .)+
  last:Newline? {
    var textStr = _.map(text, function (v) { return v[2]; }).join('');
    if (!_.isNull(last)) { textStr += last; }
    return new Text({ text: textStr });
  }

MarkupTail =
  first:MarkupTextWithoutIndent
  middle:MarkupTextWithIndent*
  !Endline !NormalizedToWhitespace last:.
  MarkupEndString
  &InlineMarkupFollowing {
    var children = [first].concat(middle);
    var lastText = children[children.length - 1];
    children[children.length - 1] = new Text({ text: lastText.text + last });
    return children;
  }

Emphasis =
  ('*' !'*' !NormalizedToWhitespace)
  &{ markupEndString = '*'; return true; }
  children:MarkupTail {
    return new Elements.Emphasis({ children: children });
  }

StrongEmphasis =
  ('**' !NormalizedToWhitespace)
  &{ markupEndString = '**'; return true; }
  children:MarkupTail {
    return new Elements.StrongEmphasis({ children: children });
  }

InterpretedText =
  role:(':' (!Endline !Whitespace !':' .)+ ':')?
  ('`' !NormalizedToWhitespace)
  &{ markupEndString = '`'; return true; }
  children:MarkupTail {
    var roleStr = null;
    if (!_.isNull(role)) {
      roleStr = _.map(role[1], function (v) { return v[3]; }).join('');
    }
    return new Elements.InterpretedText({ role: roleStr, children: children });
  }

// TODO(seikichi): unescaped backslash preceding a start-string end-string
InlineLiteral =
  ('``' !NormalizedToWhitespace)
  &{ markupEndString = '``'; return true; }
  children:MarkupTail {
    return new Elements.InlineLiteral({ children: children });
  }

SubstitutionReference =
  ('|' !NormalizedToWhitespace)
  &{ markupEndString = '|'; return true; }
  children:MarkupTail {
    return new Elements.SubstitutionReference({ children: children });
  }

InlineInternalTarget =
  ('_`' !NormalizedToWhitespace)
  &{ markupEndString = '`'; return true; }
  children:MarkupTail {
    return new Elements.InlineInternalTarget({  children: children });
  }

FootnoteLabel =
  label:([0-9]+ / '#' ReferenceName / '#' / '*') {
    if (_.isArray(label)) {
      return label.join('');
    }
    return label;
  }

FootnoteReference =
  '[' label:FootnoteLabel ']_' &InlineMarkupFollowing {
    return new Elements.FootnoteReference({ children: [new Text({ text: label })] });
  }

CitationReference =
  '[' label:ReferenceName ']_' &InlineMarkupFollowing {
    return new Elements.CitationReference({ children: [new Text({ text: label })] });
  }

HyperlinkReference =
  AnonymousHyperlinkReference /
  AnonymousSimpleHyperlinkReference /
  NamedHyperlinkReference /
  NamedSimpleHyperlinkReference

NamedHyperlinkReference =
  ('`' !NormalizedToWhitespace)
  &{ markupEndString = '`_'; return true; }
  children:MarkupTail {
    return new Elements.HyperlinkReference({ anonymous: false, simple: false, children: children });
  }

NamedSimpleHyperlinkReference =
  ref:HyperlinkReferenceName '_' &InlineMarkupFollowing {
    return new Elements.HyperlinkReference({ anonymous: false, simple: true, children: [new Text({ text: ref })] });
  }

AnonymousHyperlinkReference =
  ('`' !NormalizedToWhitespace)
  &{ markupEndString = '`__'; return true; }
  children:MarkupTail {
    return new Elements.HyperlinkReference({ anonymous: true, simple: false, children: children });
    return {children: children};
  }

AnonymousSimpleHyperlinkReference =
  ref:HyperlinkReferenceName '__' &InlineMarkupFollowing {
    return new Elements.HyperlinkReference({ anonymous: true, simple: true, children: [new Text({ text: ref })] });
  }

// Reference
ReferenceName =
  head:AlphanumericAscii
  tail:(AlphanumericAscii / [-_.:+])+ {
    return head + tail.join('');
  }

HyperlinkReferenceName =
  head:AlphanumericAscii
  tail:(AlphanumericAscii / [-.:+])+ {
    return head + tail.join('');
  }

// Utility
AlphanumericAscii = [A-Za-z0-9]
Eof = !.
Newline = '\n' / ('\r' '\n'?)
Whitespace = ' ' / '\v' / '\f' / '\t'
Endline = Newline / Eof
NormalizedToWhitespace = Whitespace / Newline
Nonspacechar = !NormalizedToWhitespace .

BlankLines =
  (Whitespace* Newline &(Whitespace* Endline))*
  Whitespace*
  Endline

RawLine =
  raw:(!Endline .)+ Endline {
    return { raw: _.map(raw, function (v) { return v[1]; }).join('') };
  }

Indent =
  &(i:Whitespace+ &{
    var size = ParserUtil.calcIndentSize(i);
    if (size <= currentIndentSize) { return false; }
    nextIndentSize = size;
    return true;
  })
  &((Whitespace* Newline / i:Whitespace+ RawLine &{
    var size = ParserUtil.calcIndentSize(i);
    if (size <= currentIndentSize) { return false; }
    nextIndentSize = Math.min(nextIndentSize, size);
    return true;
  })*)
  &{
    indentSizeStack.push(currentIndentSize);
    currentIndentSize = nextIndentSize;
    return true;
  }

Dedent =
  &{
    currentIndentSize = indentSizeStack.pop();
    return true;
  }

EndIndent = &(
  BlankLines?
  i:Whitespace* !NormalizedToWhitespace . &{
    return ParserUtil.calcIndentSize(i) < currentIndentSize
  })

SameIndent =
  i:Whitespace* &{
    var ignore = indentIgnoreLine === location().start.line;
    return ignore || ParserUtil.calcIndentSize(i) === currentIndentSize;
  } {
    return i.join('');
  }
