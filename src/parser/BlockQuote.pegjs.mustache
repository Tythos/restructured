BlockQuote = NestedBlockQuote / SimpleBlockQuote

NestedBlockQuote =
  blanks:BlankLines?
  indent:PushFirstIndent$
    nested:(BlockQuoteBody / FailbackIndent$)
    attribution:Attribution?
    &(BlankLines ShallowIndent / FailbackIndent$)
  PopIndent$
  outer:BlockQuote {
    var first = new Elements.BlockQuote({ children: nested, attribution: attribution })
        .withLoc(location, options)
        .withBlankLines([], [], options);
    if (options.indent) {
      first = first.withIndent({ size: indent.size, diff: indent.size - outer.indent.size }, options);
    }
    var children = [first].concat(outer.children.toArray());
    return new Elements.BlockQuote({ children: children })
      .withIndent(outer.indent, options)
      .withBlankLines(blanks, [], options);
  }

SimpleBlockQuote =
  blanks:BlankLines?
  indent:PushFirstIndent$
    children:(BlockQuoteBody / FailbackIndent$)
    attribution:Attribution?
  PopIndent$ {
    return new Elements.BlockQuote({ children: children, attribution: attribution })
      .withIndent(indent, options)
      .withBlankLines(blanks, [], options);
  }

BlockQuoteBody =
  head:BodyElementExceptBlockQuote
  tail:(!Attribution BodyElement)* {
    return [head].concat(_.map(tail, function (v) { return v[1]; }));
  }

Attribution =
  BlankLines
  SameIndent ('---' / '--' / '\u2014') Whitespace* &(!Endline .)
  body:(AttributionBodyWithIndent / AttributionBodyWithoutIndent) {
    return new Elements.Attribution({ children: body.children });
  }

PushAttributionIndent$ = &(RawLine PushFirstIndent$)

AttributionBodyWithIndent = PushAttributionIndent$ SkipIndentCheck$ body:(Paragraph / FailbackIndent$) PopIndent$ {
  return body;
}

AttributionBodyWithoutIndent = SkipIndentCheck$ body:Paragraph { return body; }
