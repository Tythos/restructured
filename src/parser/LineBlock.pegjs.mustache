LineBlock = NestedLineBlock / SimpleLineBlock

NestedLineBlock =
  indent:PushLiteralBlockIndent$
  head:Line tail:(Line / LineBlock)*
  PopLiteralBlockIndent$
  outer:LineBlock {
    var first = new Elements.LineBlock({ children: [head].concat(tail) });
    var children = [first].concat(outer.children);
    return new Elements.LineBlock({ children });
}

SimpleLineBlock = indent:PushLiteralBlockIndent$ block:(LineBolockMain / FailbackLiteralBlockIndent$) PopLiteralBlockIndent$ {
  return block;
}

LineBolockMain = head:Line tail:(Line / LineBlock)* &BlankLines {
  return new Elements.LineBlock({ children: [head, ...tail] });
}

Line = NonEmptyLine / EmptyLine

NonEmptyLine = SameIndent '| ' SameLiteralBlockIndent children:OnelineParagraph Newline {
  return new Elements.Line({ children });
}

EmptyLine = SameIndent '|' Whitespace* Newline {
  return new Elements.Line({ children: [] });
}

SameLiteralBlockIndent = i:Whitespace* &{
  return ParserUtil.calcIndentSize(i) === literalBlockState.current();
} {
  return i.join('');
}

DeepLiteralBlockIndent = i:Whitespace* &{
  return ParserUtil.calcIndentSize(i) > literalBlockState.current();
} {
  return i.join('');
}

PushLiteralBlockIndent$ =
  &(EmptyLine* SameIndent '| ' i:DeepLiteralBlockIndent &{
    literalBlockState.push(ParserUtil.calcIndentSize(i));
    return true;
  }) {
    return { width: literalBlockState.current(), offset: literalBlockState.diff() };
  }

PopLiteralBlockIndent$ = &{ literalBlockState.pop(); return true; }

FailbackLiteralBlockIndent$ = PopLiteralBlockIndent$ Fail$
