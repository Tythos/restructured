LineBlock = NestedLineBlock / SimpleLineBlock

NestedLineBlock =
  indent:PushLiteralBlockIndent$
  head:Line tail:(Line / LineBlock)*
  PopLiteralBlockIndent$
  outer:LineBlock {
    var first = new Elements.LineBlock({ children: [head].concat(tail) })
        .withLoc(location, options);
    if (options.indent) {
      first = first.withIndent({ size: indent.size, diff: indent.size - outer.indent.size }, options);
    }
    var children = [first].concat(outer.children.toArray());
    return new Elements.LineBlock({ children: children })
      .withIndent(outer.indent, options);
}

SimpleLineBlock = indent:PushLiteralBlockIndent$ block:(LineBolockMain / FailbackLiteralBlockIndent$) PopLiteralBlockIndent$ {
  if (indent.size === 0) { indent.diff = 0; }
  return block.withIndent(indent, options);
}

LineBolockMain = head:Line tail:(Line / LineBlock)* &BlankLines {
  return new Elements.LineBlock({ children: [head].concat(tail) });
}

Line = NonEmptyLine / EmptyLine

NonEmptyLine = SameIndent '| ' SameLiteralBlockIndent children:OnelineParagraph Newline {
  return new Elements.Line({ children: children });
}

EmptyLine = SameIndent '|' Whitespace* Newline {
  return new Elements.Line({ children: [] });
}

SameLiteralBlockIndent = i:Whitespace* &{
  return ParserUtil.calcIndentSize(i) === literalBlockState.current();
} {
  return i.join('');
}

DeepLiteralBlockIndent = i:Whitespace* &{
  return ParserUtil.calcIndentSize(i) > literalBlockState.current();
} {
  return i.join('');
}

PushLiteralBlockIndent$ =
  &(EmptyLine* SameIndent '| ' i:DeepLiteralBlockIndent &{
    literalBlockState.push(ParserUtil.calcIndentSize(i));
    return true;
  }) {
    return { size: literalBlockState.current(), diff: literalBlockState.diff() };
  }

PopLiteralBlockIndent$ = &{ literalBlockState.pop(); return true; }

FailbackLiteralBlockIndent$ = PopLiteralBlockIndent$ Fail$
